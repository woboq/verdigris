
find_package(Qt6 COMPONENTS Quick REQUIRED)

# ++++ TODO: create cmake utility
# notes:
# - Two step approach to prevent CMake from generating circular rules
# - An object library with all sources + custom rule to extract metatypes.json
# - A static library where we inject the metatypes as if they were generated by moc
# TODOs:
# - This has proof of concept quality. Improve to make more usable.
# - The injection has some side effects as not all properties are setup correctly (Inspect/PR welcome)
#   Eg. Usually Qt creates a folder in build path where qmltypes/qmldir and all qml files are stored.
# - Qt usually does not use generated files directly. But I have no idea why.
function(extract_metatypesjson target obj_target)
  set(input_files $<TARGET_OBJECTS:${obj_target}>)
  set(output_file "meta_types/${target}_$<CONFIG>_metatypes.json")
  target_link_libraries(${target}
    PUBLIC ${obj_target}
  )
  _qt_internal_get_tool_wrapper_script_path(tool_wrapper)
  add_custom_command(
    OUTPUT ${output_file}
    COMMAND
      ${tool_wrapper}
      $<TARGET_FILE:metatypes_extractor> --out=${output_file} ${input_files}
    DEPENDS metatypes_extractor ${input_files}
    COMMENT "Extracting metatypes"
  )
  add_custom_target("${target}_metatypesjson"
    DEPENDS ${output_file}
  )
  add_dependencies(${target} "${target}_metatypesjson")
  set_target_properties(${target} PROPERTIES
    INTERFACE_QT_MODULE_HAS_META_TYPES YES
    INTERFACE_QT_META_TYPES_BUILD_FILE ${output_file}
  )
  target_compile_definitions(${obj_target}
    PRIVATE QML_ELEMENT_BASE_PATH="${CMAKE_CURRENT_SOURCE_DIR}"
  )
endfunction()
# ----

add_library(qml_element_obj OBJECT
  "MyObject.h" "MyObject.cpp"
)
target_link_libraries(qml_element_obj
  PUBLIC verdigris
  PUBLIC Qt6::Quick
)

add_executable(qml_elemment_tutorial
  "main.cpp"
)
extract_metatypesjson(qml_elemment_tutorial qml_element_obj)
qt6_add_qml_module(qml_elemment_tutorial
  URI QmlTutorial
  VERSION 1.0
  QML_FILES main.qml
)
